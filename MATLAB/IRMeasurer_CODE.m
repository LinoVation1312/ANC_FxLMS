% Generated by Impulse Response Measurer on 15-Aug-2025 15:12:40 UTC+02:00.

%% Device Settings
device = "XXXXXXXXXXX"; % Audio device name
fs = 8000;				% Sample rate (Hz)
L = 4096; 				% Samples per frame
recChMap = [1 2];		% Recorder channel mapping
latencyPlayCh = 1;		% Latency player channel
latencyRecCh = 1;		% Latency recorder channel
playChMapAll = 1;		% Player channel map including latency channel
recChMapAll = [1 2];	% Recorder channel map including latency channel
nbPlayChAll = 1;		% Total number of playback channels
nbRecCh = 2;			% Total number of recorder channels

%% Method Settings (Exponential Swept Sine)
durationPerRun = 47; 	% Duration per Run (s)
outputLevel = 0;		% Excitation Level (dBFS)
% Advanced Run Settings
nbWarmUps = 0;			% Number of warm-up runs
% Advanced Excitation Settings
sweepRange = [30 300]; % Sweep start/stop frequency (Hz)
sweepDur = 45;			% Sweep Duration (s)
% IR measurement duration corresponds to the silent time after the sweep
irDur = durationPerRun - sweepDur;

%% Create the excitation signal
% The signal is constructed so that the device is opened only once,
% because latency may be different on every run on some systems

% First, generate a short sweep for measuring latency
latencySweepLevel = outputLevel - 6;
latencySweep = sweeptone( ...
    0.5,max(1,irDur),fs, ...
    ExcitationLevel=latencySweepLevel, ...
    SweepFrequencyRange=[fs/2000 fs/20]);

% Use sweeptone to generate one run of the excitation
exc = sweeptone( ...
    sweepDur,irDur,fs, ...
    ExcitationLevel=outputLevel, ...
    SweepFrequencyRange=sweepRange);

% Add startup silence
lengthPreSilence = max(ceil(0.1*fs),L);
startSilenceAndLatency = zeros(lengthPreSilence+length(latencySweep),nbPlayChAll);
excSequence = [ ...
    startSilenceAndLatency; ...
    repmat(exc,1,nbPlayChAll)];
% Keep track of which parts correspond to the excitation and not silence
recIdx = logical([ ...
    startSilenceAndLatency(:,1); ...
    ones(size(exc))]);

% Insert latency sequence
latencyCh = (playChMapAll==latencyPlayCh);
% Insert the latency sweep in the selected channel
excSequence(lengthPreSilence+1:lengthPreSilence+length(latencySweep), latencyCh) = latencySweep;

% Allocate the input/output buffers
sequenceLength = size(excSequence,1);
bufExc = dsp.AsyncBuffer(sequenceLength+L);
bufRec = dsp.AsyncBuffer(sequenceLength+2*L);

% Copy the excitation to the output buffer (including one extra
% frame of silence to account for minimum latency of one frame)
write(bufExc,excSequence);
write(bufExc,zeros(L,nbPlayChAll));

%% Play and capture using the selected device
disp("Recording...")

% Setup the capture device
apr = audioPlayerRecorder( ...
    fs,Device=device, ...
    PlayerChannelMapping=playChMapAll, ...
    RecorderChannelMapping=recChMapAll);
setup(apr,zeros(L,nbPlayChAll));

% Playback and capture loop
while bufExc.NumUnreadSamples > 0
    x = read(bufExc,L);
    [y,under,over] = apr(x);
    write(bufRec,y);
    if under>0 || over>0
        error("Underrun or overrun occurred, terminating measurement")
    end
end

% Release the audio device
release(apr);

%% Compute the results
disp("Computing results...")

% Get the recording from the input buffer, but throw
% away the first frame (minimum latency is one frame)
read(bufRec,L);
rec = read(bufRec);

% Compute latency
latencyIdx = (recChMapAll==latencyRecCh);
sweepRec = rec(lengthPreSilence+1:lengthPreSilence+length(latencySweep),latencyIdx);
latency = computeLatency(latencySweep,sweepRec,L);

% Compute the impulse response
recWithoutPauses = rec(recIdx,:);

% Compute the impulse response of the recording
ir = impzest(exc,recWithoutPauses,WarmupRuns=nbWarmUps);
t_sec = (0:length(ir)-1).'/fs;	 % time vector

% Compute the magnitude response (IRdb)
nbPoints = 2^14;
f_Hz = linspace(0,fs/2-fs/2/nbPoints,nbPoints).';
IR2 = fft(ir,2*nbPoints,1);
IR = IR2(1:nbPoints,:);
IRdB = 20*log10(max(abs(IR),realmin));

% Compute the phase response
phase = unwrap(angle(IR));

% Remove latency from the phase response
latency_data = latency-L;
phaseLatencyRemoved = phase + 2*pi*latency_data*f_Hz/fs;
irLatencyRemoved = ir(latency_data+1:end,:);
tSecLatencyRemoved = t_sec(1:end-latency_data);

% Create output structure
capture = struct(zeros(0,nbRecCh));
for ii = 1:nbRecCh
    capture(ii).ImpulseResponse.Time = t_sec;
    capture(ii).ImpulseResponse.Amplitude = ir(:,ii);
    capture(ii).MagnitudeResponse.MagnitudeDB = IRdB(:,ii);
    capture(ii).MagnitudeResponse.Frequency = f_Hz;
    capture(ii).PhaseResponse.Phase = phase(:,ii);
    capture(ii).PhaseResponse.Frequency = f_Hz;
    capture(ii).ImpulseResponse.TimeLatencyRemoved = tSecLatencyRemoved;
    capture(ii).ImpulseResponse.AmplitudeLatencyRemoved = irLatencyRemoved(:,ii);
    capture(ii).PhaseResponse.PhaseLatencyRemoved = phaseLatencyRemoved(:,ii);
    capture(ii).PhaseResponse.Frequency = f_Hz;
    capture(ii).Latency.Samples = latency;
    capture(ii).Latency.Seconds = latency/fs;
end

%% Display results
f = clf; % clear and reuse figure
tl = tiledlayout(f,2,1);
title(tl,"Impulse Response Measurement")
ax1 = plotTile(tl,tSecLatencyRemoved,irLatencyRemoved,[1 1],"linear","off","Impulse Response","Amplitude","Time (s)");
plotTile(tl,f_Hz,IRdB,[1 1],"log","off","Magnitude Response","Magnitude (dB)","Frequency (Hz)");
leg = legend(ax1,compose("Ch. %d",recChMap),Orientation="horizontal");
leg.Layout.Tile = "south";

%% Compute latency using a sweep recording
function latency = computeLatency(latencySweep, sweepRec, L)
% Verify loopback quality
xc = xcorr(latencySweep,sweepRec);
Nx0 = (size(xc,1)+1)/2;
v = max(xc(1:Nx0));
if v < 0.01 || v/rms(xc(1:Nx0)) < 10
    error("The sound level or SNR of the recording was too low. " + ...
        "Verify that the loopback is connected to the selected " + ...
        "channels and that any hardware gains are set correctly.")
else % feedback is present, compute latency
    loopIR = impzest(latencySweep,sweepRec);
    [~,loopIdx] = max(abs(loopIR));
    latency = loopIdx+L-1;
end
end

%% Plot one tile in the figure
function ax = plotTile(tile,x,y,tilespan,xScale,dbMode,titlelbl,ylbl,xlbl)
ax = nexttile(tile,tilespan);
if strcmp(dbMode,"on")
    y = 20*log10(abs(y)+realmin(class(y)));
end
plot(ax,x,y)
ax.XScale = xScale;
xlim(ax,"tight");
ylim(ax,"padded");
title(ax,titlelbl)
ylabel(ax,ylbl)
xlabel(ax,xlbl)
grid(ax,"on")
end

%% SAVE THE FILE AND MODIFY THE PRONY.m CODE IF YOU WANT TO USE THIS RAW CODE